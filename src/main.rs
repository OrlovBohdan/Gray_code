fn gray(n: u8) -> Vec<String> {
    if n == 0 {
        return vec![String::new()];
    }

    let mut result = Vec::new();
    let total = 1 << n; // Це 2^n

    for i in 0..total {
        let gray_code = i ^ (i >> 1); // Генерація коду Грея за допомогою XOR числа з його зсувом вправо на 1 біт
        let binary_string = format!("{:0width$b}", gray_code, width = n as usize); // Форматування у двійковий рядок з 'n' бітами
        result.push(binary_string);
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_gray() {
        let test_data = [
            (0, vec![""]),
            (1, vec!["0", "1"]),
            (2, vec!["00", "01", "11", "10"]),
            (3, vec!["000", "001", "011", "010", "110", "111", "101", "100"]),
            (4, vec![
                "0000", "0001", "0011", "0010",
                "0110", "0111", "0101", "0100",
                "1100", "1101", "1111", "1110",
                "1010", "1011", "1001", "1000"
            ]),
        ];

        for (n, expected) in test_data.iter() {
            assert_eq!(gray(*n), *expected);
        }
    }
}

/*

Gray code (Код Грея) — це двійкова система числення, у якій дві послідовні величини відрізняються лише одним бітом.
Такий підхід часто використовується в цифрових системах для запобігання помилкам під час переходів між станами.

Код Грея для числа i генерується за формулою i ^ (i >> 1).
Макрос format! форматує число у двійковий рядок із n бітами.
Тест перевіряє, чи функція правильно генерує коди Грея для кількості бітів від 0 до 4.
*/
